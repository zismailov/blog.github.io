title: "Creating associations to existing data part 1: belongs_to scaffolding"
date: 2010/01/25
tag: View Mapper

<p>I decided it would be fun to look into various different types of Rails forms that allow you to create a new object that is associated with existing data. In my next few posts, I&rsquo;ll explore different ways to select existing records, and also how to work with has_and_belongs_to_many and has_many, through relationships in a Rails form. It seems to me that these use cases are more common than the nested models form in the <a href="http://github.com/ryanb/complex-form-examples">complex-form-examples</a> sample app that creates new records but doesn't associate with existing ones.</p>
<p>To start with today, here&rsquo;s the simplest such form I could think of &ndash; I call this a &ldquo;belongs_to&rdquo; form:<br/>
<img src="http://patshaughnessy.net/assets/2010/1/24/new_shirt.png"/>
<p>Here we can see a form for a new &ldquo;shirt&rdquo; record; along with the color and size the user can also select the person who owns the shirt. In this example, the shirt and person models have a has_many/belongs_to relationship. This form uses simple HTML &lt;select&gt; and &lt;option&gt; tags to display the list of people, and is generated by Rails ERB code that uses &ldquo;collection_select&rdquo; like this:
<div class="CodeRay">
  <div class="code"><pre><span class="no"> 1</span> <span class="ta">&lt;p&gt;</span>
<span class="no"> 2</span>   Person:<span class="ta">&lt;br</span> <span class="ta">/&gt;</span>
<span class="no"> 3</span>   <span class="il"><span class="idl">&lt;%=</span> f.collection_select(<span class="sy">:person_id</span>,
<span class="no"> 4</span>                           <span class="co">Person</span>.all,
<span class="no"> 5</span>                           <span class="sy">:id</span>,
<span class="no"> 6</span>                           <span class="sy">:name</span>,
<span class="no"> 7</span>                           { <span class="sy">:prompt</span> =&gt; <span class="pc">true</span> })
<span class="no"> 8</span>   <span class="idl">%&gt;</span></span>
<span class="no"> 9</span> <span class="ta">&lt;/p&gt;</span></pre></div>
</div></p>
<p>The parameters passed to collection_select here indicate that we want to display all of the people that exist, and set the value and label for each &lt;option&gt; tag to the id and name of each person respectively. When the form is submitted, the &ldquo;person_id&rdquo; field for this shirt is set to the &ldquo;id&rdquo; value of the selected person.</p>
<p><b>Belongs_to scaffolding with View Mapper</b></p>
<p>If you need a form like this in your app, you can use my <a href="http://patshaughnessy.net/view_mapper">View Mapper gem</a> to generate it for your models as follows&hellip; first install it from gemcutter; you&rsquo;ll need version 0.3.2 at least for this form:
<div class="CodeRay">
  <div class="code"><pre>$ gem sources -a http://gemcutter.org
http://gemcutter.org added to sources 
$ sudo gem install view_mapper
Successfully installed view_mapper-0.3.2
</pre></div>
</div></p>
<p>Then you can generate the belongs_to view scaffolding you see above like this:</p>
<div class="CodeRay">
  <div class="code"><pre>$ ./script/generate view_for shirt --view belongs_to</pre></div>
</div></p>
<p>View Mapper will open the specified model (&ldquo;Shirt&rdquo;), detect the associated model(s) that Shirt belongs to, and then generate the form using collection_select along with all of the other standard scaffolding files. You can also have View Mapper generate the new Shirt model and the view scaffolding code at the same time like this:
<div class="CodeRay">
  <div class="code"><pre>./script/generate scaffold_for_view shirt color:string size:integer
                                    --view belongs_to:person</pre></div>
</div></p>
<p>Here you&rsquo;ve specified the desired attributes for the new shirt model, along with the fact that you want it to belong to a person.</p>
<p>To make the generated view code simple and concise, View Mapper makes a couple of assumptions about your models:
  <ul>
    <li>It assumes the parent model (&ldquo;Person&rdquo; in this example) has an attribute or method called &ldquo;name.&rdquo; This is used to display the list of people.</li>
    <li>It also assumes the child model (&ldquo;Shirt&rdquo;) has a method to display the name of the parent model it belongs to (&ldquo;person_name&rdquo; in this example).</li>
    </ul></p>
<p>I decided not to make the View Mapper command line more complex than it already is by providing a way to pass the &ldquo;name&rdquo; attribute as another parameter. Instead you can just edit the scaffolding code it produces as desired.</p>
<p><b>Detailed example and code review</b></p>
<p>Let&rsquo;s create a sample app now together using View Mapper, and then review how this &ldquo;belongs_to view&rdquo; works. First, create a new Rails app:</p>
<div class="CodeRay">
  <div class="code"><pre>$ rails belongs_to
      create  
      create  app/controllers
      create  app/helpers
      create  app/models
      create  app/views/layouts
      create  config/environments
      etc...</pre></div>
</div></p>
<p>And now let&rsquo;s create the Person model with first and last name attributes; I&rsquo;ll also use the console to create a few Person records so we have some existing data to work with:
<div class="CodeRay">
  <div class="code"><pre>$ cd belongs_to
$ ./script/generate model person first_name:string last_name:string
      exists  app/models/
      exists  test/unit/
      exists  test/fixtures/
      create  app/models/person.rb
      create  test/unit/person_test.rb
      create  test/fixtures/people.yml
      create  db/migrate
      create  db/migrate/20100124120247_create_people.rb
$ rake db:migrate
(in /Users/pat/rails-apps/belongs_to)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0030s
==  CreatePeople: migrated (0.0032s) ==========================================
 $ ./script/console 
Loading development environment (Rails 2.3.5)
&gt;&gt; Person.create :first_name =&gt; 'Barack', :last_name =&gt; 'Obama'
&gt;&gt; Person.create :first_name =&gt; 'George', :last_name =&gt; 'Bush'
&gt;&gt; Person.create :first_name =&gt; 'Bill',   :last_name =&gt; 'Clinton'</pre></div>
</div></p>
<p>Now let&rsquo;s go ahead and run View Mapper to create the form&hellip;
<div class="CodeRay">
  <div class="code"><pre>$ ./script/generate scaffold_for_view shirt color:string size:integer
                                      --view belongs_to:person
     warning  Model Person does not contain a has_many association for Shirt.</pre></div>
</div></p>
<p>Here View Mapper is warning us that we haven&rsquo;t called &ldquo;has_many :shirts&rdquo; in the Person model yet; let&rsquo;s edit person.rb and enter that code:
<div class="CodeRay">
  <div class="code"><pre><span class="no">1</span> <span class="r">class</span> <span class="cl">Person</span> &lt; <span class="co">ActiveRecord</span>::<span class="co">Base</span>
<span class="no">2</span>   has_many <span class="sy">:shirts</span>
<span class="no">3</span> <span class="r">end</span></pre></div>
</div>
<p>Now we can try again:
<div class="CodeRay">
  <div class="code"><pre>$ ./script/generate scaffold_for_view shirt color:string size:integer
                                      --view belongs_to:person
     warning  Model Person does not have a name attribute.</pre></div>
</div></p>
<p>Above I mentioned that View Mapper assumes the parent model has a &ldquo;name&rdquo; attribute or method. This is required to know how to display each person record in the &lt;select&gt; drop down box on the form. Remember in the call to collection_select we passed in the symbol &ldquo;:name&rdquo; &ndash; this tells Rails to call the name method for the label of each &lt;option&gt; tag. So let&rsquo;s create a name method in the Person model that displays the first and last name attributes together:
<div class="CodeRay">
  <div class="code"><pre><span class="no">1</span> <span class="r">class</span> <span class="cl">Person</span> &amp;lt; <span class="co">ActiveRecord</span>::<span class="co">Base</span>
<span class="no">2</span>   has_many <span class="sy">:shirts</span>
<div class='container'><span class="no">3</span>   <span class="r">def</span> <span class="fu">name</span>
<span class="no">4</span>     <span class="s"><span class="dl">&quot;</span><span class="il"><span class="idl">#{</span>first_name<span class="idl">}</span></span><span class="k"> </span><span class="il"><span class="idl">#{</span>last_name<span class="idl">}</span></span><span class="dl">&quot;</span></span>
<span class="no">5</span>   <span class="r">end</span><span class='overlay'></span></div><span class="no">6</span> <span class="r">end</span>
</pre></div></p>
</div></p>
<p>The highlighted code returns the first and last names concatenated together as a single name. Now View Mapper won&rsquo;t complain and we can go ahead and create our new form:
<div class="CodeRay">
  <div class="code"><pre>$ ./script/generate scaffold_for_view shirt color:string size:integer
                                      --view belongs_to:person
      exists  app/models/
      exists  app/controllers/
… etc …

<div class='container'>     create  app/views/shirts/_form.html.erb<span class='overlay'></span></div>
… etc …
      exists  test/fixtures/
      create  app/models/shirt.rb
      create  db/migrate/20100124121032_create_shirts.rb</pre></div>
</div>
</p>
<p>Note the output here looks just like what you get from the standard Rails scaffold generator, except for the one additional line I highlighted above. If you run your app now, you&rsquo;ll be able to see scaffolding for the Shirts model at http://localhost:3000/shirts, and you&rsquo;ll see the person select box on the new and edit forms.</p>
<p>Let me take a few more minutes to point out a couple of interesting details about the belongs_to scaffolding&hellip; first I&rsquo;ve moved the form fields into a partial shared among the new and edit views; this is the new _form.html.erb file highlighted above in the generator output. If you look at new.html.erb, you&rsquo;ll see a call to render :partial:
<div class="CodeRay">
  <div class="code"><pre><span class="no"> 1</span> <span class="ta">&lt;h1&gt;</span>New shirt<span class="ta">&lt;/h1&gt;</span>
<span class="no"> 2</span> 
<span class="no"> 3</span> <span class="il"><span class="idl">&lt;%</span> form_for(<span class="iv">@shirt</span>) <span class="r">do</span> |f| <span class="idl">%&gt;</span></span>
<div class='container'><span class="no"> 4</span>   <span class="il"><span class="idl">&lt;%=</span> render <span class="sy">:partial</span> =&gt; <span class="s"><span class="dl">'</span><span class="k">form</span><span class="dl">'</span></span>, <span class="sy">:locals</span> =&gt; { <span class="sy">:f</span> =&gt; f } <span class="idl">%&gt;</span></span><span class='overlay'></span></div><span class="no"> 5</span>   <span class="ta">&lt;p&gt;</span>
<span class="no"> 6</span>     <span class="il"><span class="idl">&lt;%=</span> f.submit <span class="s"><span class="dl">'</span><span class="k">Create</span><span class="dl">'</span></span> <span class="idl">%&gt;</span></span>
<span class="no"> 7</span>   <span class="ta">&lt;/p&gt;</span>
<span class="no"> 8</span> <span class="il"><span class="idl">&lt;%</span> <span class="r">end</span> <span class="idl">%&gt;</span></span>
<span class="no"> 9</span> 
<span class="no">10</span> <span class="il"><span class="idl">&lt;%=</span> link_to <span class="s"><span class="dl">'</span><span class="k">Back</span><span class="dl">'</span></span>, shirts_path <span class="idl">%&gt;</span></span></pre></div>
</div></p>
<p>The edit.html.erb file looks similar. The actual call to collection_select is in _form.html.erb; that way if you need to display the list of people differently, for example to use a method other than &ldquo;name&rdquo; for each person or possibly to use a filtered list of people instead of Person.all, then you just need to make your changes in one place.</p>
<p>And one more interesting detail: if you open up the new Shirts model that View Mapper generated you&rsquo;ll see this:
<div class="CodeRay">
  <div class="code"><pre><span class="no">1</span> <span class="r">class</span> <span class="cl">Shirt</span> &lt; <span class="co">ActiveRecord</span>::<span class="co">Base</span>
<span class="no">2</span>   belongs_to <span class="sy">:person</span>
<div class='container'><span class="no">3</span>   <span class="r">def</span> <span class="fu">person_name</span>
<span class="no">4</span>     person.name <span class="r">if</span> person
<span class="no">5</span>   <span class="r">end</span><span class='overlay'></span></div><span class="no">6</span> <span class="r">end</span></pre></div>
</div></p>
<p>The person_name method I highlighted above returns the person each shirt belongs to; it also checks if person is nil for that shirt. This simplifies the code in index.html.erb and show.html.erb; take a look at show.html.erb for example:
<div class="CodeRay">
  <div class="code"><pre><span class="no"> 1</span> <span class="ta">&lt;p&gt;</span>
<span class="no"> 2</span>   <span class="ta">&lt;b&gt;</span>Color:<span class="ta">&lt;/b&gt;</span>
<span class="no"> 3</span>   <span class="il"><span class="idl">&lt;%=</span>h <span class="iv">@shirt</span>.color <span class="idl">%&gt;</span></span>
<span class="no"> 4</span> <span class="ta">&lt;/p&gt;</span>
<span class="no"> 5</span> 
<span class="no"> 6</span> <span class="ta">&lt;p&gt;</span>
<span class="no"> 7</span>   <span class="ta">&lt;b&gt;</span>Size:<span class="ta">&lt;/b&gt;</span>
<span class="no"> 8</span>   <span class="il"><span class="idl">&lt;%=</span>h <span class="iv">@shirt</span>.size <span class="idl">%&gt;</span></span>
<span class="no"> 9</span> <span class="ta">&lt;/p&gt;</span>
<span class="no">10</span> 
<div class='container'><span class="no">11</span> <span class="ta">&lt;p&gt;</span>
<span class="no">12</span>   <span class="ta">&lt;b&gt;</span>Person:<span class="ta">&lt;/b&gt;</span>
<span class="no">13</span>   <span class="il"><span class="idl">&lt;%=</span>h <span class="iv">@shirt</span>.person_name <span class="idl">%&gt;</span></span>
<span class="no">14</span> <span class="ta">&lt;/p&gt;</span><span class='overlay'></span></div><span class="no">15</span> 
<span class="no">16</span> <span class="il"><span class="idl">&lt;%=</span> link_to <span class="s"><span class="dl">'</span><span class="k">Edit</span><span class="dl">'</span></span>, edit_shirt_path(<span class="iv">@shirt</span>) <span class="idl">%&gt;</span></span> |
<span class="no">17</span> <span class="il"><span class="idl">&lt;%=</span> link_to <span class="s"><span class="dl">'</span><span class="k">Back</span><span class="dl">'</span></span>, shirts_path <span class="idl">%&gt;</span></span></pre></div>
</div></p>
<p>Here the Person field looks just like any other field from the Shirt model. There&rsquo;s no need to repeat the check for person == nil in the view, and if you ever need to use a Person attribute other than name or if you needed to find the associated person in some more complex way, you&rsquo;ll only need to make the change to the model and not in each view file.</p>
<p>Again, if you run View Mapper on two has_many/belongs_to models that you&rsquo;ve already written in your app, you will first need to provide:
  <ul>
    <li>A &ldquo;name&rdquo; method in the parent model, if it&rsquo;s not already an attribute, and</li>
    <li>A &ldquo;[parent_model]_name&rdquo; method in the child model</li></ul></p>
<p>If these two methods don&rsquo;t exist, View Mapper will display warning messages and not proceed; this avoids the confusion you would run into when the scaffolding view code didn&rsquo;t work.</p>
<p>Next time, I&rsquo;ll repeat this example but use type ahead/auto_complete to select the person instead...</p>
