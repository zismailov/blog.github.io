title: "How does Kaminari paginate?"
date: 2011/9/10
tag: Ruby

<div style="float: left; padding: 7px 30px 10px 0px">
<table cellpadding="0" cellspacing="0" border="0">
  <tr><td><img src="http://patshaughnessy.net/assets/2011/9/8/thunder.jpg"></td></tr>
  <tr><td align="center"><small><i>“Kaminari” means thunder in Japanese</i></small></td></tr>
</table>
</div>

Kaminari is a popular new gem that provides pagination behavior - to learn how to use it  see the Railscast [Pagination with Kaminari](http://railscasts.com/episodes/254-pagination-with-kaminari), or just refer to the [Github readme page](https://github.com/amatsuda/kaminari). For me Kaminari is a good example of “Rails magic...” somehow by just adding the gem to my Rails application all of my models get the Kaminari <span class="code">page</span> method. I don’t have even have to type a single line of code in my model... it’s just automatically added for me. Then when I call <span class="code">page</span>, it immediately works: returning just the records for a given page, even working in conjunction with other scopes I might have.

Today I’m going to take a closer look under the hood at how Kaminari actually works. For me the most beautiful part of the Ruby language is the way it allows talented open source developers like Akira Matsuda to make their code seem elegant, beautiful and magical.

## The Kaminari page scope

Here’s what a call to the Kaminari <span class="code">page</span> method looks like - your controller receives the page to display as an HTTP parameter: <span class="code">params[:page]</span>, and passes it into Kaminari. The <span class="code">per(5)</span> call indicates you want to override the default and display five people per page:

<div class="CodeRay"> 
  <div class="code"><pre><span class="r">def</span> <span class="fu">index</span> 
  <span class="iv">@people</span> = <span class="co">Person</span>.page(params[<span class="sy">:page</span>]).per(<span class="i">5</span>)
<span class="r">end</span></pre></div> 
</div></p>

One reason Kaminari became popular this year is that it cleanly leverages Rails 3 scopes to refine the result set to the specified page. Using ActiveRecord, for example, a call to <span class="code">Person.page(3).per(5)</span> will return an ActiveRecord::Relation scope object that looks something like this:

![page scope](http://patshaughnessy.net/assets/2011/9/8/page_scope.png)

An ActiveRecord::Relation object encapsulates some values, saved as instance variables, that will later be used to generate the SQL statement sent to your relational database server. This happens when your view code uses the ActiveRecord::Relation object as an array, for example when you call <span class="code">@people.each</span>. In this diagram I’ve shown just two values that are used by Kaminari for pagination:

<ul>
  <li>@limit_value: how many records to return in total (i.e. one page worth instead of all of them)</li>
  <li>@offset_value: which record to start the result set with (i.e. the record at the top of the specified page)</li>
</ul>

For <span class="code">Person.page(3).per(5)</span> Kaminari will set @limit_value to 5, the number of records per page, and the @offset_value to to 10, which is the zero-based index of the first record on the third page.

The nice thing about scopes is that you can chain them together to create a more complex, refined query. For example, I can display a paginated list of legal drinking age people like this:

<div class="CodeRay"> 
  <div class="code"><pre><span class="co">Person</span>.where(<span class="er">"</span>age &gt;= ?", <span class="i">21</span>).page(params[<span class="sy">:page</span>]).per(<span class="i">5</span>)
</pre></div>
</div>

Here the <span class="code">where</span> method first returns a scope containing the age filter:

![filter scope](http://patshaughnessy.net/assets/2011/9/8/filter_scope.png)

It turns out that filter options set by using the <span class="code">where</span> method are saved as multiple values in an array. You can checkout the [ActiveRecord::Relation source code](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/relation.rb) for more information. Next the call to the <span class="code">page</span> method combines the pagination options with that and a single, more complex scope is returned:

![page scope 2](http://patshaughnessy.net/assets/2011/9/8/page_scope2.png)

## Inspecting pagination SQL statements in the console

The best way to understand how scopes work is to experiment with them in the console, and inspect the SQL statements generated by ActiveRecord using the <span class="code">to_sql</span> method. Let’s give it a try. First, here’s the SQL produced by ActiveRecord and the MySQL database adapter for a call to <span class="code">Person.page(3).per(5)</span>:

<div class="CodeRay"> 
  <div class="code"><pre>$ rails c
Loading development environment (Rails 3.1.0)
ruby-1.8.7-p302 :001 &gt; Person.page(3).per(5).to_sql
 =&gt; &quot;SELECT  `people`.* FROM `people`  LIMIT 5 OFFSET 10&quot; </pre></div> 
</div> 

Now you can see how the LIMIT and OFFSET values from the page scope are actually used in the SQL statement. Let’s try again but this time include the age filter

<div class="CodeRay"> 
  <div class="code"><pre>ruby-1.8.7-p302 :002 &gt; Person.where(&quot;age &gt; ?&quot;, 21).page(3).per(5).to_sql
 =&gt; &quot;SELECT  `people`.* FROM `people`  WHERE (age &gt; 21) LIMIT 5 OFFSET 10&quot; </pre></div> 
</div> 

Here ActiveRecord has just combined the options from the two scopes together and produced a single SQL statement.

## How does Kaminari create the page scope?

Finally, let’s take a quick look at how Akira Matsuda actually implemented this inside of Kaminari. You can find the code that implements the <span class="code">page</span> method for ActiveRecord models in the [active_record_model_extension.rb](https://github.com/amatsuda/kaminari/blob/master/lib/kaminari/models/active_record_model_extension.rb) file inside of the Kaminari gem:

<div class="CodeRay"> 
  <div class="code"><pre>require <span class="co">File</span>.join(<span class="co">File</span>.dirname(<span class="pc">__FILE__</span>), <span class="s"><span class="dl">'</span><span class="k">active_record_relation_methods</span><span class="dl">'</span></span>)
 
<span class="r">module</span> <span class="cl">Kaminari</span> 
  <span class="r">module</span> <span class="cl">ActiveRecordExtension</span> 
    extend <span class="co">ActiveSupport</span>::<span class="co">Concern</span> 
    included <span class="r">do</span> 
      <span class="r">def</span> <span class="pc">self</span>.inherited(kls) <span class="c">#:nodoc:</span> 
        <span class="r">super</span> 
 
        kls.class_eval <span class="r">do</span> 
          include <span class="co">Kaminari</span>::<span class="co">ConfigurationMethods</span> 
 
          <span class="c"># Fetch the values at the specified page number</span> 
          <span class="c">#   Model.page(5)</span> 
<div class='container'>          scope <span class="sy">:page</span>, <span class="co">Proc</span>.new {|num|
            limit(default_per_page).offset(default_per_page * ([num.to_i, <span class="i">1</span>].max - <span class="i">1</span>))
          } <span class="r">do</span> <span class='overlay'></span></div>            include <span class="co">Kaminari</span>::<span class="co">ActiveRecordRelationMethods</span> 
            include <span class="co">Kaminari</span>::<span class="co">PageScopeMethods</span> 
          <span class="r">end</span>
        <span class="r">end</span> 
      <span class="r">end</span> 
    <span class="r">end</span> 
  <span class="r">end</span> 
<span class="r">end</span></pre></div> 
</div> 

There’s a lot of metaprogramming going on here, so let’s take it one step at a time. The first thing to learn is that the Kaminari::ActiveRecordExtension module uses ActiveRecord::Concern, which provides a standard way to add behavior to some target Ruby class. [This well written article](http://www.fakingfantastic.com/2010/09/20/concerning-yourself-with-active-support-concern) does a nice job of explaining how ActiveSupport::Concern works in Rails 3. Elsewhere in the gem source code Kaminari::ActiveRecordExtension is included in ActiveRecord::Base, which becomes the target class in this case. The rest of the code reads something like this:
<ul>
  <li>When Kaminari:: ActiveRecordExtension is included in ActiveRecord::Base...</li>
  <li>Create a class method on ActiveRecord::Base called <span class="code">inherited</span>...</li>
  <li>Then this will be called when the Rails developer writes a new ActiveRecord model...</li>
  <li>Then open the new ActiveRecord model class using <span class="code">class_eval</span>, e.g. my Person model...</li>
  <li>Include some new methods in it from Kaminari::ConfigurationMethods...
  <li>And finally call <span class="code">scope</span> to add the page scope.</li>
</ul>

Here’s the most important line of code, which adds the Kaminari page scope to each new ActiveRecord::Base subclass:

<div class="CodeRay"> 
  <div class="code"><pre>scope <span class="sy">:page</span>, <span class="co">Proc</span>.new {|num|
  limit(default_per_page).offset(default_per_page * ([num.to_i, <span class="i">1</span>].max - <span class="i">1</span>))
}
</div>
</div>

We call <span class="code">scope</span> and pass in the symbol <span class="code">:page</span> followed by a Proc, which is the scope definition. This means that in fact Kaminari does not actually implement a new method called page, it just creates a scope with that name and adds it to the ActiveRecord::Base class.

In other words, by calling <span class="code">scope :page</span> Kaminari is doing exactly the same thing you would if you had written this code yourself:

<div class="CodeRay"> 
  <div class="code"><pre><span class="r">class</span> <span class="cl">Person</span> &lt; <span class="co">ActiveRecord</span>::<span class="co">Base</span> 
  scope <span class="sy">:page</span>, <span class="co">Proc</span>.new {|num|
<span class="er"> </span><span class="er"> </span><span class="er"> </span><span class="er"> </span><span class="er"> </span><span class="er"> </span><span class="er"> </span><span class="er"> </span>limit(default_per_page).offset(default_per_page * ([num.to_i, <span class="i">1</span>].max - <span class="i">1</span>))
<span class="er"> </span><span class="er"> </span><span class="er"> </span><span class="er"> </span><span class="er"> </span><span class="er"> </span>}
etc...</pre></div> 
</div> 

Finally, actually reading the Proc's definition, you can see that the limit value is set to the number of records per page <span class="code">default_per_page</span>, the offset value is calculated based on the number of records per page, and the page number passed in <span class="code">num</span>. Since the scope is a Proc, it is evaluated every time it is used, for the given value of <span class="code">num</span>.
